package im.tox.tox4j.impl.jni.codegen

import im.tox.tox4j.av.ToxAv
import im.tox.tox4j.core.ToxCore
import im.tox.tox4j.impl.jni.codegen.NameConversions.cxxVarName
import im.tox.tox4j.impl.jni.codegen.cxx.Ast._
import im.tox.tox4j.impl.jni.{ AutoGenerated, MethodMap, ToxAvJni, ToxCoreJni }

import scala.reflect.runtime.{ universe => u }

object JniMethodImpls extends CodeGenerator {

  val typeMap = Map(
    "int" -> Type.jint
  )

  def generateNativeCode[T](jniClass: Class[_])(implicit evidence: u.TypeTag[T]): TranslationUnit = {
    val mirror = u.runtimeMirror(jniClass.getClassLoader)
    val traitMirror = mirror.typeOf[T]

    val methods = MethodMap(jniClass).filter(_._2.getAnnotation(classOf[AutoGenerated]) != null)
    methods.foreach {
      case (name, method) =>
        val traitMethod = traitMirror.member(u.TermName(name))
        System.out.println(traitMethod)
    }
    methods.values.toSeq
      .flatMap { method =>
        Seq(
          ToxFun(
            returnType = typeMap(method.getReturnType.getName),
            name = method.getName,
            params = Seq(Param(Type.jint, "instanceNumber")),
            body = CompoundStmt(
              // instances.with_instance_noerr (env, instanceNumber,
              //   tox_iteration_interval);
              Return(FunCall(
                Access(Identifier("instances"), "with_instance_noerr"),
                Seq(
                  Identifier("env"),
                  Identifier("instanceNumber"),
                  Identifier(cxxVarName(method.getName))
                )
              ))
            )
          )
        )
      }
  }

  writeCode("ToxAv/generated/impls.h", "\n") {
    Comment(classOf[ToxAvJni].getName) +:
      generateNativeCode[ToxAv[_]](classOf[ToxAvJni])
  }

  writeCode("ToxCore/generated/impls.h", "\n") {
    Comment(classOf[ToxCoreJni].getName) +:
      generateNativeCode[ToxCore[_]](classOf[ToxCoreJni])
  }

}
